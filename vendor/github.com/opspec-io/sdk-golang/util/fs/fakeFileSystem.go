// This file was generated by counterfeiter
package fs

import (
	"os"
	"sync"
)

type FakeFileSystem struct {
	AddDirStub        func(pathToDir string) (err error)
	addDirMutex       sync.RWMutex
	addDirArgsForCall []struct {
		pathToDir string
	}
	addDirReturns struct {
		result1 error
	}
	GetBytesOfFileStub        func(pathToFile string) (bytesOfFile []byte, err error)
	getBytesOfFileMutex       sync.RWMutex
	getBytesOfFileArgsForCall []struct {
		pathToFile string
	}
	getBytesOfFileReturns struct {
		result1 []byte
		result2 error
	}
	ListChildFileInfosOfDirStub        func(pathToDir string) (childFileInfos []os.FileInfo, err error)
	listChildFileInfosOfDirMutex       sync.RWMutex
	listChildFileInfosOfDirArgsForCall []struct {
		pathToDir string
	}
	listChildFileInfosOfDirReturns struct {
		result1 []os.FileInfo
		result2 error
	}
	SaveFileStub        func(pathToFile string, bytesOfFile []byte) (err error)
	saveFileMutex       sync.RWMutex
	saveFileArgsForCall []struct {
		pathToFile  string
		bytesOfFile []byte
	}
	saveFileReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFileSystem) AddDir(pathToDir string) (err error) {
	fake.addDirMutex.Lock()
	fake.addDirArgsForCall = append(fake.addDirArgsForCall, struct {
		pathToDir string
	}{pathToDir})
	fake.recordInvocation("AddDir", []interface{}{pathToDir})
	fake.addDirMutex.Unlock()
	if fake.AddDirStub != nil {
		return fake.AddDirStub(pathToDir)
	} else {
		return fake.addDirReturns.result1
	}
}

func (fake *FakeFileSystem) AddDirCallCount() int {
	fake.addDirMutex.RLock()
	defer fake.addDirMutex.RUnlock()
	return len(fake.addDirArgsForCall)
}

func (fake *FakeFileSystem) AddDirArgsForCall(i int) string {
	fake.addDirMutex.RLock()
	defer fake.addDirMutex.RUnlock()
	return fake.addDirArgsForCall[i].pathToDir
}

func (fake *FakeFileSystem) AddDirReturns(result1 error) {
	fake.AddDirStub = nil
	fake.addDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) GetBytesOfFile(pathToFile string) (bytesOfFile []byte, err error) {
	fake.getBytesOfFileMutex.Lock()
	fake.getBytesOfFileArgsForCall = append(fake.getBytesOfFileArgsForCall, struct {
		pathToFile string
	}{pathToFile})
	fake.recordInvocation("GetBytesOfFile", []interface{}{pathToFile})
	fake.getBytesOfFileMutex.Unlock()
	if fake.GetBytesOfFileStub != nil {
		return fake.GetBytesOfFileStub(pathToFile)
	} else {
		return fake.getBytesOfFileReturns.result1, fake.getBytesOfFileReturns.result2
	}
}

func (fake *FakeFileSystem) GetBytesOfFileCallCount() int {
	fake.getBytesOfFileMutex.RLock()
	defer fake.getBytesOfFileMutex.RUnlock()
	return len(fake.getBytesOfFileArgsForCall)
}

func (fake *FakeFileSystem) GetBytesOfFileArgsForCall(i int) string {
	fake.getBytesOfFileMutex.RLock()
	defer fake.getBytesOfFileMutex.RUnlock()
	return fake.getBytesOfFileArgsForCall[i].pathToFile
}

func (fake *FakeFileSystem) GetBytesOfFileReturns(result1 []byte, result2 error) {
	fake.GetBytesOfFileStub = nil
	fake.getBytesOfFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ListChildFileInfosOfDir(pathToDir string) (childFileInfos []os.FileInfo, err error) {
	fake.listChildFileInfosOfDirMutex.Lock()
	fake.listChildFileInfosOfDirArgsForCall = append(fake.listChildFileInfosOfDirArgsForCall, struct {
		pathToDir string
	}{pathToDir})
	fake.recordInvocation("ListChildFileInfosOfDir", []interface{}{pathToDir})
	fake.listChildFileInfosOfDirMutex.Unlock()
	if fake.ListChildFileInfosOfDirStub != nil {
		return fake.ListChildFileInfosOfDirStub(pathToDir)
	} else {
		return fake.listChildFileInfosOfDirReturns.result1, fake.listChildFileInfosOfDirReturns.result2
	}
}

func (fake *FakeFileSystem) ListChildFileInfosOfDirCallCount() int {
	fake.listChildFileInfosOfDirMutex.RLock()
	defer fake.listChildFileInfosOfDirMutex.RUnlock()
	return len(fake.listChildFileInfosOfDirArgsForCall)
}

func (fake *FakeFileSystem) ListChildFileInfosOfDirArgsForCall(i int) string {
	fake.listChildFileInfosOfDirMutex.RLock()
	defer fake.listChildFileInfosOfDirMutex.RUnlock()
	return fake.listChildFileInfosOfDirArgsForCall[i].pathToDir
}

func (fake *FakeFileSystem) ListChildFileInfosOfDirReturns(result1 []os.FileInfo, result2 error) {
	fake.ListChildFileInfosOfDirStub = nil
	fake.listChildFileInfosOfDirReturns = struct {
		result1 []os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) SaveFile(pathToFile string, bytesOfFile []byte) (err error) {
	var bytesOfFileCopy []byte
	if bytesOfFile != nil {
		bytesOfFileCopy = make([]byte, len(bytesOfFile))
		copy(bytesOfFileCopy, bytesOfFile)
	}
	fake.saveFileMutex.Lock()
	fake.saveFileArgsForCall = append(fake.saveFileArgsForCall, struct {
		pathToFile  string
		bytesOfFile []byte
	}{pathToFile, bytesOfFileCopy})
	fake.recordInvocation("SaveFile", []interface{}{pathToFile, bytesOfFileCopy})
	fake.saveFileMutex.Unlock()
	if fake.SaveFileStub != nil {
		return fake.SaveFileStub(pathToFile, bytesOfFile)
	} else {
		return fake.saveFileReturns.result1
	}
}

func (fake *FakeFileSystem) SaveFileCallCount() int {
	fake.saveFileMutex.RLock()
	defer fake.saveFileMutex.RUnlock()
	return len(fake.saveFileArgsForCall)
}

func (fake *FakeFileSystem) SaveFileArgsForCall(i int) (string, []byte) {
	fake.saveFileMutex.RLock()
	defer fake.saveFileMutex.RUnlock()
	return fake.saveFileArgsForCall[i].pathToFile, fake.saveFileArgsForCall[i].bytesOfFile
}

func (fake *FakeFileSystem) SaveFileReturns(result1 error) {
	fake.SaveFileStub = nil
	fake.saveFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addDirMutex.RLock()
	defer fake.addDirMutex.RUnlock()
	fake.getBytesOfFileMutex.RLock()
	defer fake.getBytesOfFileMutex.RUnlock()
	fake.listChildFileInfosOfDirMutex.RLock()
	defer fake.listChildFileInfosOfDirMutex.RUnlock()
	fake.saveFileMutex.RLock()
	defer fake.saveFileMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeFileSystem) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ FileSystem = new(FakeFileSystem)
